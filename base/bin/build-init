#!/usr/bin/env bash

# This script sets up a sandbox environment for the build on the remote docker host.

set -e # Abort if anything fails
#set -x # Echo commands

# Cleanup
echo "Setting up remote build environment..."
if [[ "${REMOTE_BUILD_DIR_CLEANUP}" == 1 ]] || [[ "${REMOTE_CODEBASE_METHOD}" == "rsync" ]]; then
	echo "Re-initializing remote environment from scratch..."
	[[ "${REMOTE_BUILD_DIR_CLEANUP}" == 0 ]] && [[ "${REMOTE_CODEBASE_METHOD}" == "rsync" ]] && echo "rsync is not supported for preserved builds!"
	ssh docker-host "(cd ${REMOTE_BUILD_DIR} 2>/dev/null && fin rm -f 2>/dev/null) || true"
	ssh docker-host "sudo rm -rf ${REMOTE_BUILD_DIR} 2>/dev/null; mkdir -p ${REMOTE_BUILD_DIR}"
else
	echo "Cleanup disabled, only applying new changes on remote environment..."
	# Ensure directory exists. 
	ssh docker-host "mkdir -p ${REMOTE_BUILD_DIR}"
fi

# Note: build-exec = ssh docker-host "cd $REMOTE_BUILD_DIR && ($@)"

# Remote codebase initialization method. Either 'git' (default) or 'rsync'
if [[ "${REMOTE_CODEBASE_METHOD}" == "rsync" ]]; then
	# Rsync sources to the remote host
	echo "Syncing codebase via rsync..."
	rsync --delete -az ${BUILD_DIR}/ docker-host:${REMOTE_BUILD_DIR}
else
	# Checkout sources on the remote host
	echo "Checking out codebase via git..."
	if [[ "${REMOTE_BUILD_DIR_CLEANUP}" == 1 ]]; then
		build-exec "git clone --branch="${GIT_BRANCH_NAME}" --depth 50 ${GIT_REPO_URL} . && git reset --hard ${GIT_COMMIT_HASH} && ls -la"
	else
		dir_exists=$(ssh docker-host "[ -d $REMOTE_BUILD_DIR ]")
		result=$?
		if [ $result == "0" ]; then
		  # Directory exists so lets pull and reset.
		  # Uncomment for git control.
		  build-exec "git fetch origin && git reset --hard origin/$GIT_BRANCH_NAME"
		  # Uncomment for rsync control.
		  #  rsync --delete -az ${BUILD_DIR}/ docker-host:${REMOTE_BUILD_DIR}
		else
	fi
fi

# Configure sandbox settings
echo "Configuring sandbox settings..."
build-exec "fin config set COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} --env=local"
build-exec "fin config set VIRTUAL_HOST=${SANDBOX_DOMAIN} --env=local"
#build-exec "echo COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME} | tee -a .docksal/docksal-local.env"
#build-exec "echo VIRTUAL_HOST=${SANDBOX_DOMAIN} | tee -a .docksal/docksal-local.env"

# Basic HTTP Auth
if [[ "${HTTP_USER}" != "" ]] && [[ "${HTTP_PASS}" != "" ]]; then
	echo "Configuring sandbox Basic HTTP Authentication..."
	build-exec "fin config set APACHE_BASIC_AUTH_USER=${HTTP_USER} --env=local"
	build-exec "fin config set APACHE_BASIC_AUTH_PASS=${HTTP_PASS} --env=local"
	# build-exec "echo APACHE_BASIC_AUTH_USER=${HTTP_USER} | tee -a .docksal/docksal-local.env"
	# build-exec "echo APACHE_BASIC_AUTH_PASS=${HTTP_PASS} | tee -a .docksal/docksal-local.env"
fi

# Permanent environment switch
if [[ "${SANDBOX_PERMANENT}" != "" ]]; then
	echo "Setting sandbox as permanent..."
	build-exec "fin config set SANDBOX_PERMANENT=${SANDBOX_PERMANENT} --env=local"
	# build-exec "echo SANDBOX_PERMANENT=${SANDBOX_PERMANENT} | tee -a .docksal/docksal-local.env"
fi

# Pass CI_SSH_KEY to sandbox
# Note the key is passed as SECRET_SSH_PRIVATE_KEY, which docksal/cli reads, decodes and stores as ~/.ssh/id_rsa
# Disabled for now. This may be a security concern, if a single shared machine-user SSH key is used across multiple projects.
# TODO: Load the key into the docksal/ssh-agent service on the sandbox server instead.
#if [[ "${CI_SSH_KEY}" != "" ]]; then
#	echo "Passing CI_SSH_KEY to sandbox..."
#	build-exec "echo SECRET_SSH_PRIVATE_KEY=\"${CI_SSH_KEY}\" | tee -a .docksal/docksal-local.env >/dev/null"
#fi

# Pass build secrets to sandbox
# A "secret" is any environment variable that starts with "SECRET_"

secrets="$(compgen -A variable | grep '^SECRET_')" || true
# secrets="$(env | grep '^SECRET_')" || true
done
if [[ "${secrets}" != "" ]]; then
	echo "Passing build secrets to sandbox..."
	for secret in $secrets
	do
		build-exec "fin config set $secret=${!secret} --env=local >/dev/null"
	done
	# build-exec "echo '${secrets}' | tee -a .docksal/docksal-local.env >/dev/null"
fi
